compiled - can be compiled,go tool can run file directly without virtual machine 
           executables are different for operating system 



what - systems app to web apps - cloud 
       already in production 

missing - no try catchy lex er does a lot of work   


types - 
       
| **Category**                     | **Type**                                                                             | **Example**                             |
| -------------------------------- | ------------------------------------------------------------------------------------ | --------------------------------------- |
| **Boolean**                      | `bool`                                                                               | `true`, `false`                         |
| **Numeric â€“ Integer (signed)**   | `int`, `int8`, `int16`, `int32`, `int64`                                             | `var a int = 10`                        |
| **Numeric â€“ Integer (unsigned)** | `u int`, `uint8` (alias: `byte`), `uint16`, `uint32`, `uint64`, `u int p tr`             | `var b uint8 = 255`                     |
| **Numeric â€“ Floating Point**     | `float32`, `float64`                                                                 | `var pi float64 = 3.14`                 |
| **Numeric â€“ Complex**            | `complex64`, `complex128`                                                            | `z := 2 + 3i`                           |
| **Text**                         | `string`                                                                             | `"Hello, Go!"`                          |
| **Derived / Composite**          | `array`, `slice`, `map`, `struct`, `pointer`, `function`, `channel`, `interface`     | `[]int{1,2,3}`, `map[string]int{"a":1}` |
| **Alias / Special**              | `rune` (alias for `int32`, used for Unicode code points), `byte` (alias for `uint8`) | `var r rune = 'A'`                      |


Basic types â†’ numbers, bool, string.

Composite types â†’ array, slice, map, struct.

Special types â†’ rune, byte, pointer, interface, function.









In Go, bufio is a standard library package (bufio) that provides buffered I/O â€” it wraps around an io.Reader or io.Writer (like files, stdin, stdout, network connections) to make reading and writing more efficient and convenient.
Why bufio?

Without buffering â†’ every Read or Write call hits the underlying device (slow).
With bufio â†’ data is read/written in chunks (buffered in memory), reducing system calls and improving performance.
| **Function / Type**   | **Purpose**                                         |
| --------------------- | --------------------------------------------------- |
| `bufio.NewReader(r)`  | Wraps an `io.Reader` with buffering (for input).    |
| `bufio.NewWriter(w)`  | Wraps an `io.Writer` with buffering (for output).   |
| `bufio.NewScanner(r)` | Reads input line by line or token by token.         |
| `ReadString('\n')`    | Reads until a delimiter (e.g., newline).            |
| `ReadBytes(delim)`    | Reads until a delimiter and returns a byte slice.   |
| `Writer.Flush()`      | Flushes the buffered data to the underlying writer. |


bufio = buffered input/output package in Go â†’ faster, easier reading/writing of text, files, or streams.


walrus operator := is used for short variable declaration.




Goâ€™s memory management combines escape analysis, efficient per-thread allocators, and a concurrent garbage collector, allowing developers to focus on business logic while still giving room for optimization via memory-conscious coding practices



ðŸ”¹ Memory Management in Go
1. Automatic Memory Management

Go has a garbage-collected runtime â†’ you donâ€™t manually malloc/free like in C/C++.

Memory allocation is handled by the Go runtime (runtime.mallocgc).

The garbage collector (GC) automatically frees memory thatâ€™s no longer referenced.

2. Heap vs Stack

Stack: stores local variables inside functions, fast allocation, auto-freed when function exits.

Heap: used when memory escapes the function scope (e.g., returning a pointer). Garbage collected.

Go has escape analysis to decide if a variable should live on the stack or heap.

ðŸ‘‰ Example:

func foo() *int {
    x := 42   // x would normally live on stack
    return &x // but reference escapes -> allocated on heap
}

3. Garbage Collector (GC)

Go uses a concurrent, tri-color mark-and-sweep GC:

Mark â†’ runtime marks all reachable objects.

Sweep â†’ frees unreachable memory.

Runs concurrently with the program (low pause times).

Tuned for low latency instead of raw throughput.

4. Allocation Efficiency

Small objects are managed by the per-P (processor) cache allocator (mcache) â†’ very fast.

Larger objects come from the central heap (mcentral).

Even larger memory comes directly from the OS (mheap).

5. Memory Optimizations for Developers

Avoid unnecessary heap allocations â†’ prefer values over pointers when possible.

Use sync.Pool for reusing temporary objects.

Slicing carefully â†’ slicing may keep references to large underlying arrays â†’ memory leak risk.

Close resources (files, DB connections) explicitly â†’ GC only frees memory, not external resources.

6. Common Interview Talking Points

If asked in a FAANG/MAANG interview, you can summarize:

Go has a garbage collector â†’ concurrent, tri-color, low pause.

Escape analysis decides stack vs heap allocation.

Efficient allocator: mcache, mcentral, mheap.

Developers can help GC by writing allocation-friendly code (avoid escapes, reuse buffers, sync.Pool).


memory management -: new() allocate memory but no Interview
                            YOU will get a memory address ,zeroed storage
                     make() allocate memory and INIT 
                     you will get a memory address
                     non zeroed storage
                     garbage happens automatically
                     out of scope or null 





context :-                       